<template>
  <div>
    <h1 class="text-2xl font-bold mb-4">Outage Tracker</h1>

    <ag-grid-vue
      class="ag-theme-alpine-dark"
      style="width: 100%; height: 500px;"
      :rowData="outages"
      :columnDefs="columnDefs"
      :defaultColDef="defaultColDef"
      :pagination="true"
      :paginationPageSize="20"
      :modules="modules"
      @rowClicked="onRowClicked"
    ></ag-grid-vue>

    <!-- Modal -->
    <div v-if="showModal" class="modal-overlay">
      <div class="modal">
        <button class="modal-close" @click="closeModal">Ã—</button>
        <h2 class="modal-title">Outage Details</h2>
        <div class="modal-content">
          <table>
            <tbody>
              <tr v-for="(value, key) in selectedOutage" :key="key">
                <td class="font-bold">{{ key }}</td>
                <td>{{ value }}</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-actions">
          <label class="toggle-label">
            <input
              type="checkbox"
              :checked="selectedOutage.complete === 'Y'"
              @change="toggleComplete(selectedOutage)"
            />
            Complete
          </label>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { AgGridVue } from 'ag-grid-vue3';
import { ClientSideRowModelModule } from '@ag-grid-community/client-side-row-model';

export default {
  name: "OutageTable",
  components: {
    AgGridVue,
  },
  data() {
    return {
      outages: [],
      columnDefs: [
        { field: 'date', headerName: 'Date', sortable: true },
        { field: 'outageType', headerName: 'Type', sortable: true },
        { field: 'start', headerName: 'Start', sortable: true },
        { field: 'end', headerName: 'End', sortable: true },
        {
          field: 'duration',
          headerName: 'Duration',
          sortable: true,
          valueGetter: params => this.calculateDuration(params.data.start, params.data.end)
        },
        { field: 'service', headerName: 'Service', sortable: true },
        { field: 'engineer', headerName: 'Engineer', sortable: true },
        {
          field: 'latestComment',
          headerName: 'Latest Comment',
          sortable: true,
          valueGetter: params => {
            const comments = params.data.comments;
            if (comments && comments.length > 0) {
              const sortedComments = comments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              return sortedComments[0].comment;
            }
            return 'No comments';
          }
        },
        {
          field: 'complete',
          headerName: 'Completed',
          sortable: true,
          valueGetter: params => (params.data.complete === 'Y' ? 'Yes' : 'No'),
        }
      ],
      defaultColDef: {
        flex: 1,
        minWidth: 100,
        filter: true,
        resizable: true,
      },
      sortField: null,
      sortOrder: null,
      modules: [ClientSideRowModelModule],
      showModal: false,
      selectedOutage: null,
    };
  },
  async created() {
    try {
      const response = await fetch("http://127.0.0.1:5000/outages");
      if (!response.ok) {
        throw new Error(`Failed to fetch outages: ${response.statusText}`);
      }
      const data = await response.json();
      this.outages = data; // Populate table
    } catch (error) {
      console.error("Error fetching outages:", error);
    }
  },
  methods: {
    calculateDuration(start, end) {
      // If there's no end time, use current time
      if (!end || end.trim() === '') {
        const today = new Date();
        
        // Get outage date from row data
        const outageDate = new Date(this.outages.find(o => o.start === start)?.date || new Date());
        
        // Calculate days difference
        let daysDiff = Math.floor((today - outageDate) / (1000 * 60 * 60 * 24));
        
        // Format current time
        const clockHour = String(today.getHours()).padStart(2, '0');
        const clockMinute = String(today.getMinutes()).padStart(2, '0');
        
        // Use current time as end time for calculation
        end = `${clockHour}:${clockMinute}:00`; // Add seconds for calculation
        
        // Process time components
        let startParts = start.split(':');
        let endParts = end.split(':');
        
        // Add seconds if missing
        if (startParts.length === 2) startParts.push('00');
        if (endParts.length === 2) endParts.push('00');
        
        // Convert to numbers
        const startH = parseInt(startParts[0], 10);
        const startM = parseInt(startParts[1], 10);
        const startS = parseInt(startParts[2], 10);
        
        const endH = parseInt(endParts[0], 10);
        const endM = parseInt(endParts[1], 10);
        const endS = parseInt(endParts[2], 10);
        
        // Calculate time difference
        let hourDiff = endH - startH;
        let minDiff = endM - startM;
        let secDiff = endS - startS; // Keep for calculations but won't display
        
        // Handle time borrowing
        if (secDiff < 0) {
          secDiff += 60;
          minDiff--;
        }
        
        if (minDiff < 0) {
          minDiff += 60;
          hourDiff--;
        }
        
        if (hourDiff < 0) {
          hourDiff += 24;
          daysDiff--; // Borrow from days
        }
        
        // Format the result as DD:HH:MM (always showing days)
        return `${String(daysDiff).padStart(2, '0')}:${String(hourDiff).padStart(2, '0')}:${String(minDiff).padStart(2, '0')}`;
      }
      
      // When end time exists - adapt this part too
      // Process time components
      let startParts = start.split(':');
      let endParts = end.split(':');
      
      // Add seconds if missing
      if (startParts.length === 2) startParts.push('00');
      if (endParts.length === 2) endParts.push('00');
      
      // Convert to numbers
      const startH = parseInt(startParts[0], 10);
      const startM = parseInt(startParts[1], 10);
      const startS = parseInt(startParts[2], 10);
      
      const endH = parseInt(endParts[0], 10);
      const endM = parseInt(endParts[1], 10);
      const endS = parseInt(endParts[2], 10);
      
      // Calculate time difference
      let hourDiff = endH - startH;
      let minDiff = endM - startM;
      let secDiff = endS - startS;
      let daysDiff = 0; // Start with 0 days when we have both times
      
      // Handle time borrowing
      if (secDiff < 0) {
        secDiff += 60;
        minDiff--;
      }
      
      if (minDiff < 0) {
        minDiff += 60;
        hourDiff--;
      }
      
      if (hourDiff < 0) {
        hourDiff += 24;
        daysDiff--; // Borrow from days
      }
      
      // Format the result as DD:HH:MM
      return `${String(daysDiff).padStart(2, '0')}:${String(hourDiff).padStart(2, '0')}:${String(minDiff).padStart(2, '0')}`;
    },

    compareDuration(durationA, durationB, sortOrder) {
      const [hoursA, minutesA, secondsA] = durationA.split(':').map(Number);
      const [hoursB, minutesB, secondsB] = durationB.split(':').map(Number);
      const totalSecondsA = hoursA * 3600 + minutesA * 60 + secondsA;
      const totalSecondsB = hoursB * 3600 + minutesB * 60 + secondsB;
      return (totalSecondsA - totalSecondsB) * sortOrder;
    },
    async toggleComplete(outage) {
      try {
        // Toggle the complete status
        outage.complete = outage.complete === 'Y' ? 'N' : 'Y';

        // Create a copy of the outage object without the comments field
        const updatedOutage = { ...outage };
        delete updatedOutage.comments;

        // Convert the date field to 'YYYY-MM-DD' format
        if (updatedOutage.date) {
          const date = new Date(updatedOutage.date);
          updatedOutage.date = date.toISOString().split('T')[0]; // Extract 'YYYY-MM-DD'
        }

        // Send the update to the backend
        const response = await fetch(`http://127.0.0.1:5000/outage/${outage.id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updatedOutage),
        });

        if (!response.ok) {
          throw new Error(`Failed to update outage: ${response.statusText}`);
        }

        // Update the local data
        const index = this.outages.findIndex(o => o.id === outage.id);
        if (index !== -1) {
          // Replace the object in the array to trigger reactivity
          this.outages.splice(index, 1, { ...updatedOutage });
        }
      } catch (error) {
        console.error("Error updating outage:", error);
      }
    },
    async deleteOutage(outageId) {
      try {
        const response = await fetch(`/outages/${outageId}`, {
          method: 'DELETE'
        });
        if (response.ok) {
          this.outages = this.outages.filter(outage => outage.id !== outageId);
        } else {
          console.error('Failed to delete outage');
        }
      } catch (error) {
        console.error('Error:', error);
      }
    },
    onRowClicked(event) {
      this.selectedOutage = { ...event.data }; // Clone the data to avoid direct mutation
      this.showModal = true;
    },
    closeModal() {
      this.showModal = false;
      this.selectedOutage = null;
    },
  }
};
</script>

<style>
@import 'ag-grid-community/styles/ag-grid.css';
@import 'ag-grid-community/styles/ag-theme-alpine.css';

/* Add styles for the toggle */
.toggle-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 16px;
  color: var(--ag-foreground-color);
}

.toggle-label input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
}
</style>
