<template>
  <div>
    <h1 class="text-2xl font-bold mb-4">Outage Tracker</h1>
    <table class="table-auto w-full border-collapse border border-gray-300">
      <thead>
        <tr class="bg-gray-100">
          <th class="border px-4 py-2">Date</th>
          <th class="border px-4 py-2">Type</th>
          <th class="border px-4 py-2">Start</th>
          <th class="border px-4 py-2">End</th>
          <th class="border px-4 py-2">Duration</th>
          <th class="border px-4 py-2">Comment</th>
          <th class="border px-4 py-2">Engineer</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="(outage, index) in outages" :key="index">
          <td class="border px-4 py-2">{{ outage.date }}</td>
          <td class="border px-4 py-2">{{ outage.outageType }}</td>
          <td class="border px-4 py-2">{{ outage.start }}</td>
          <td class="border px-4 py-2">{{ outage.end }}</td>
          <td class="border px-4 py-2">{{ outage.duration }}</td>
          <td class="border px-4 py-2">{{ outage.comment }}</td>
          <td class="border px-4 py-2">{{ outage.engineer }}</td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script>
export default {
  name: "OutageTable",
  data() {
    return {
      outages: [],
    };
  },
  async created() {
    try {
      // Make sure your Flask server is running on localhost:5000
      const response = await fetch("http://localhost:5000/outages");
      
      if (!response.ok) {
        throw new Error(`Failed to fetch outages: ${response.statusText}`);
      }

      const data = await response.json();
      this.outages = data; // Populate table
    } catch (error) {
      console.error("Error fetching outages:", error);
    }
  },
};
</script>

















SELECT
    -- Format the month start date into 'YYYY-MM' format for reporting.
    DATE_FORMAT(periods.month_start, '%Y-%m') AS report_month,

    -- Include the queue ID for grouping and reporting purposes.
    j.queue_id,

    -- Calculate the GPU utilization for the month.
    ROUND(
        (
            SUM(
                TIMESTAMPDIFF(
                    SECOND,
                    GREATEST(j.start_time, periods.month_start),
                    LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                ) / 3600 * j.ngpu
            ) / (
                -- Total available hours in the month = GPU Count * Days in Month * Hours in a Day.
                CASE
                    WHEN j.queue_id = 'mlaas' THEN 40
                    WHEN j.queue_id = 'mlaas_a100' THEN 20
                    WHEN j.queue_id = 'mlaas_h100' THEN 48
                END * DATEDIFF(periods.month_end, periods.month_start) * 24
            )
        ) * 100, 2
    ) AS utilization_percentage,

    -- Calculate the weighted average of the utilizations for 'mlaas', 'mlaas_a100', and 'mlaas_h100'.
    ROUND(
        (
            (SUM(CASE
                    WHEN j.queue_id = 'mlaas' THEN
                        TIMESTAMPDIFF(
                            SECOND,
                            GREATEST(j.start_time, periods.month_start),
                            LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                        ) / 3600 * j.ngpu
                    ELSE 0
                END) * 1) +
            (SUM(CASE
                    WHEN j.queue_id = 'mlaas_a100' THEN
                        TIMESTAMPDIFF(
                            SECOND,
                            GREATEST(j.start_time, periods.month_start),
                            LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                        ) / 3600 * j.ngpu
                    ELSE 0
                END) * 2) +
            (SUM(CASE
                    WHEN j.queue_id = 'mlaas_h100' THEN
                        TIMESTAMPDIFF(
                            SECOND,
                            GREATEST(j.start_time, periods.month_start),
                            LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                        ) / 3600 * j.ngpu
                    ELSE 0
                END) * 4)
        ) / (
            7 * DATEDIFF(periods.month_end, periods.month_start) * 24
        ), 2
    ) AS weighted_utilization_percentage
FROM (
    -- Generate a list of start and end dates for the last 6 months.
    SELECT
        -- Generate the 15th of each month as the approximate start date of the reporting period.
        DATE_FORMAT(DATE_ADD(LAST_DAY(NOW()), INTERVAL -m.num MONTH), '%Y-%m-15') AS month_start,

        -- Calculate the last day of the corresponding month as the end of the reporting period.
        LAST_DAY(DATE_ADD(LAST_DAY(NOW()), INTERVAL -m.num MONTH)) AS month_end
    FROM (
        -- Create a simple list of numbers (0 to 5) to represent the last 6 months.
        SELECT 1 AS num
    ) m
) periods
-- Join the jobs table to the generated period ranges to aggregate GPU usage and pending hours.
LEFT JOIN job_hal_mlaas j
ON 
    -- Ensure the job starts before the period's end date.
    j.start_time < periods.month_end

    -- Exclude jobs with a '0000-00-00 00:00:00' start time (indicating the job hasn't started).
    AND j.start_time != '0000-00-00 00:00:00'

    -- Include jobs that are either completed or incomplete but overlap with the period.
    AND (j.complete_date >= periods.month_start OR j.complete_date IS NULL)
WHERE
    -- Filter only jobs in the 'mlaas', 'mlaas_a100', or 'mlaas_h100' queues.
    j.queue_id = 'mlaas' or j.queue_id = 'mlaas_a100' or j.queue_id = 'mlaas_h100' 
GROUP BY
    -- Group the results by the period's start and end dates and queue ID.
    periods.month_start, periods.month_end, j.queue_id
