# app.py

from flask import Flask, request, jsonify
import mysql.connector
from mysql.connector import Error
from flask_cors import CORS

# Optional: load env variables from .env
# from dotenv import load_dotenv
# import os
# load_dotenv()  # take environment variables from .env

app = Flask(__name__)
CORS(app)  # Allow cross-origin requests from Vue

# You can store these in environment variables or a config file
DB_HOST = "localhost"
DB_USER = "root"
DB_PASSWORD = "your_password"
DB_NAME = "outage_tracker"
DB_PORT = 3306

def get_connection():
    """Create and return a new MySQL database connection."""
    return mysql.connector.connect(
        host=DB_HOST,
        user=DB_USER,
        password=DB_PASSWORD,
        database=DB_NAME,
        port=DB_PORT
    )

@app.route("/")
def home():
    return "Outage Tracker Flask API is running!"

@app.route("/init", methods=["GET"])
def init_db():
    """Create the 'outages' table if it doesn't exist."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS outages (
                id INT AUTO_INCREMENT PRIMARY KEY,
                date DATE NOT NULL,
                outageType VARCHAR(255) NOT NULL,
                start TIME NOT NULL,
                end TIME NOT NULL,
                duration VARCHAR(100),
                comment TEXT,
                engineer VARCHAR(255)
            )
        """)
        conn.commit()
        cursor.close()
        conn.close()
        return jsonify({"message": 'Table "outages" created or already exists'})
    except Error as e:
        return jsonify({"error": str(e)}), 500

# -------------------------------------------------------------------
# CRUD Endpoints
# -------------------------------------------------------------------

@app.route("/outages", methods=["GET"])
def get_outages():
    """Retrieve all outages from the database."""
    try:
        conn = get_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM outages")
        rows = cursor.fetchall()
        cursor.close()
        conn.close()
        return jsonify(rows)  # returns a list of dict
    except Error as e:
        return jsonify({"error": str(e)}), 500

@app.route("/outages", methods=["POST"])
def create_outage():
    """
    Create a new outage record.
    Expects JSON in body: 
      {
        "date": "YYYY-MM-DD",
        "outageType": "string",
        "start": "HH:MM:SS",
        "end": "HH:MM:SS",
        "duration": "string",
        "comment": "string",
        "engineer": "string"
      }
    """
    data = request.json
    if not data:
        return jsonify({"error": "No input data provided"}), 400
    
    try:
        conn = get_connection()
        cursor = conn.cursor()
        sql = """INSERT INTO outages (date, outageType, start, end, duration, comment, engineer)
                 VALUES (%s, %s, %s, %s, %s, %s, %s)"""
        val = (
            data.get("date"),
            data.get("outageType"),
            data.get("start"),
            data.get("end"),
            data.get("duration"),
            data.get("comment"),
            data.get("engineer")
        )
        cursor.execute(sql, val)
        conn.commit()
        new_id = cursor.lastrowid
        cursor.close()
        conn.close()
        
        return jsonify({"id": new_id, **data}), 201
    except Error as e:
        return jsonify({"error": str(e)}), 500

@app.route("/outages/<int:outage_id>", methods=["PUT"])
def update_outage(outage_id):
    """
    Update an existing outage record by ID.
    Expects JSON in body (same fields as POST).
    """
    data = request.json
    if not data:
        return jsonify({"error": "No input data provided"}), 400
    
    try:
        conn = get_connection()
        cursor = conn.cursor()
        sql = """UPDATE outages
                 SET date=%s, outageType=%s, start=%s, end=%s, duration=%s, comment=%s, engineer=%s
                 WHERE id=%s"""
        val = (
            data.get("date"),
            data.get("outageType"),
            data.get("start"),
            data.get("end"),
            data.get("duration"),
            data.get("comment"),
            data.get("engineer"),
            outage_id
        )
        cursor.execute(sql, val)
        conn.commit()
        cursor.close()
        conn.close()
        if cursor.rowcount == 0:
            return jsonify({"error": f"No outage found with id {outage_id}"}), 404
        return jsonify({"message": f"Outage {outage_id} updated"})
    except Error as e:
        return jsonify({"error": str(e)}), 500

@app.route("/outages/<int:outage_id>", methods=["DELETE"])
def delete_outage(outage_id):
    """Delete an outage by ID."""
    try:
        conn = get_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM outages WHERE id=%s", (outage_id,))
        conn.commit()
        cursor.close()
        conn.close()
        if cursor.rowcount == 0:
            return jsonify({"error": f"No outage found with id {outage_id}"}), 404
        return jsonify({"message": f"Outage {outage_id} deleted"})
    except Error as e:
        return jsonify({"error": str(e)}), 500

# -------------------------------------------------------------------
# Run Flask App
# -------------------------------------------------------------------
if __name__ == "__main__":
    app.run(port=5000, debug=True)












SELECT
    -- Format the month start date into 'YYYY-MM' format for reporting.
    DATE_FORMAT(periods.month_start, '%Y-%m') AS report_month,

    -- Include the queue ID for grouping and reporting purposes.
    j.queue_id,

    -- Calculate the GPU utilization for the month.
    ROUND(
        (
            SUM(
                TIMESTAMPDIFF(
                    SECOND,
                    GREATEST(j.start_time, periods.month_start),
                    LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                ) / 3600 * j.ngpu
            ) / (
                -- Total available hours in the month = GPU Count * Days in Month * Hours in a Day.
                CASE
                    WHEN j.queue_id = 'mlaas' THEN 40
                    WHEN j.queue_id = 'mlaas_a100' THEN 20
                    WHEN j.queue_id = 'mlaas_h100' THEN 48
                END * DATEDIFF(periods.month_end, periods.month_start) * 24
            )
        ) * 100, 2
    ) AS utilization_percentage,

    -- Calculate the weighted average of the utilizations for 'mlaas', 'mlaas_a100', and 'mlaas_h100'.
    ROUND(
        (
            (SUM(CASE
                    WHEN j.queue_id = 'mlaas' THEN
                        TIMESTAMPDIFF(
                            SECOND,
                            GREATEST(j.start_time, periods.month_start),
                            LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                        ) / 3600 * j.ngpu
                    ELSE 0
                END) * 1) +
            (SUM(CASE
                    WHEN j.queue_id = 'mlaas_a100' THEN
                        TIMESTAMPDIFF(
                            SECOND,
                            GREATEST(j.start_time, periods.month_start),
                            LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                        ) / 3600 * j.ngpu
                    ELSE 0
                END) * 2) +
            (SUM(CASE
                    WHEN j.queue_id = 'mlaas_h100' THEN
                        TIMESTAMPDIFF(
                            SECOND,
                            GREATEST(j.start_time, periods.month_start),
                            LEAST(IFNULL(j.complete_date, periods.month_end), periods.month_end)
                        ) / 3600 * j.ngpu
                    ELSE 0
                END) * 4)
        ) / (
            7 * DATEDIFF(periods.month_end, periods.month_start) * 24
        ), 2
    ) AS weighted_utilization_percentage
FROM (
    -- Generate a list of start and end dates for the last 6 months.
    SELECT
        -- Generate the 15th of each month as the approximate start date of the reporting period.
        DATE_FORMAT(DATE_ADD(LAST_DAY(NOW()), INTERVAL -m.num MONTH), '%Y-%m-15') AS month_start,

        -- Calculate the last day of the corresponding month as the end of the reporting period.
        LAST_DAY(DATE_ADD(LAST_DAY(NOW()), INTERVAL -m.num MONTH)) AS month_end
    FROM (
        -- Create a simple list of numbers (0 to 5) to represent the last 6 months.
        SELECT 1 AS num
    ) m
) periods
-- Join the jobs table to the generated period ranges to aggregate GPU usage and pending hours.
LEFT JOIN job_hal_mlaas j
ON 
    -- Ensure the job starts before the period's end date.
    j.start_time < periods.month_end

    -- Exclude jobs with a '0000-00-00 00:00:00' start time (indicating the job hasn't started).
    AND j.start_time != '0000-00-00 00:00:00'

    -- Include jobs that are either completed or incomplete but overlap with the period.
    AND (j.complete_date >= periods.month_start OR j.complete_date IS NULL)
WHERE
    -- Filter only jobs in the 'mlaas', 'mlaas_a100', or 'mlaas_h100' queues.
    j.queue_id = 'mlaas' or j.queue_id = 'mlaas_a100' or j.queue_id = 'mlaas_h100' 
GROUP BY
    -- Group the results by the period's start and end dates and queue ID.
    periods.month_start, periods.month_end, j.queue_id
